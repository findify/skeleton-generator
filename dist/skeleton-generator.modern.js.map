{"version":3,"file":"skeleton-generator.modern.js","sources":["../node_modules/element-to-path/dist/element-to-path.umd.js","../templates.js","../node_modules/nanoid/index.browser.js","../index.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.elementToPath = factory());\n}(this, (function () { 'use strict';\n\n  const chunkArray = (arr, size = 2) => {\n    let results = [];\n    while (arr.length) {\n      results.push(arr.splice(0, size));\n    }\n    return results\n  };\n\n  const calcValue = (val, base) => {\n    return /%$/.test(val) ? (val.replace('%', '') * 100) / base : +val\n  };\n\n  const rect = attrs => {\n    const w = +attrs.width;\n    const h = +attrs.height;\n    const x = attrs.x ? +attrs.x : 0;\n    const y = attrs.y ? +attrs.y : 0;\n    let rx = attrs.rx || 'auto';\n    let ry = attrs.ry || 'auto';\n    if (rx === 'auto' && ry === 'auto') {\n      rx = ry = 0;\n    } else if (rx !== 'auto' && ry === 'auto') {\n      rx = ry = calcValue(rx, w);\n    } else if (ry !== 'auto' && rx === 'auto') {\n      ry = rx = calcValue(ry, h);\n    } else {\n      rx = calcValue(rx, w);\n      ry = calcValue(ry, h);\n    }\n    if (rx > w / 2) {\n      rx = w / 2;\n    }\n    if (ry > h / 2) {\n      ry = h / 2;\n    }\n    const hasCurves = rx > 0 && ry > 0;\n    return [\n      `M${x + rx} ${y}`,\n      `H${x + w - rx}`,\n      ...(hasCurves ? [`A${rx} ${ry} 0 0 1 ${x + w} ${y + ry}`] : []),\n      `V${y + h - ry}`,\n      ...(hasCurves ? [`A${rx} ${ry} 0 0 1 ${x + w - rx} ${y + h}`] : []),\n      `H${x + rx}`,\n      ...(hasCurves ? [`A${rx} ${ry} 0 0 1 ${x} ${y + h - ry}`] : []),\n      `V${y + ry}`,\n      ...(hasCurves ? [`A${rx} ${ry} 0 0 1 ${x + rx} ${y}`] : []),\n      'z',\n    ]\n  };\n\n  const ellipse = attrs => {\n    const cx = +attrs.cx;\n    const cy = +attrs.cy;\n    const rx = attrs.rx ? +attrs.rx : +attrs.r;\n    const ry = attrs.ry ? +attrs.ry : +attrs.r;\n    return [\n      `M${cx + rx} ${cy}`,\n      `A${rx} ${ry} 0 0 1 ${cx} ${cy + ry}`,\n      `A${rx} ${ry} 0 0 1 ${cx - rx} ${cy}`,\n      `A${rx} ${ry} 0 0 1 ${cx + rx} ${cy}`,\n      'z',\n    ]\n  };\n\n  const line = ({ x1, y1, x2, y2 }) => {\n    return [`M${+x1} ${+y1}`, `L${+x2} ${+y2}`]\n  };\n\n  const poly = attrs => {\n    const { points } = attrs;\n    const pointsArray = points\n      .trim()\n      .split(' ')\n      .reduce((arr, point) => {\n        return [...arr, ...(point.includes(',') ? point.split(',') : [point])]\n      }, []);\n\n    const pairs = chunkArray(pointsArray, 2);\n    return pairs.map(([x, y], i) => {\n      return `${i === 0 ? 'M' : 'L'}${x} ${y}`\n    })\n  };\n\n  const toPathString = d => {\n    return Array.isArray(d) ? d.join(' ') : ''\n  };\n\n  const elementToPath = (\n    node,\n    { nodeName = 'name', nodeAttrs = 'attributes' } = {}\n  ) => {\n    const name = node[nodeName];\n    const attributes = node[nodeAttrs];\n    let d;\n    if (name === 'rect') {\n      d = rect(attributes);\n    }\n\n    if (name === 'circle' || name === 'ellipse') {\n      d = ellipse(attributes);\n    }\n\n    if (name === 'line') {\n      d = line(attributes);\n    }\n\n    if (name === 'polyline') {\n      d = poly(attributes);\n    }\n\n    if (name === 'polygon') {\n      d = [...poly(attributes), 'Z'];\n    }\n\n    if (name === 'path') {\n      return attributes.d\n    }\n\n    return toPathString(d)\n  };\n\n  return elementToPath;\n\n})));\n","export const trim = string => props => string(props)\n  .replace(/(\\r\\n|\\n|\\r)/gm, \"\")\n\nexport const animation = `\n  <linearGradient id=\"fill\">\n    <stop\n      offset=\"0.599964\"\n      stop-color=\"#f3f3f3\"\n      stop-opacity=\"1\"\n    >\n      <animate\n        attributeName=\"offset\"\n        values=\"-2; -2; 1\"\n        keyTimes=\"0; 0.25; 1\"\n        dur=\"2s\"\n        repeatCount=\"indefinite\"\n      ></animate>\n    </stop>\n    <stop\n      offset=\"1.59996\"\n      stop-color=\"#ecebeb\"\n      stop-opacity=\"1\"\n    >\n      <animate\n        attributeName=\"offset\"\n        values=\"-1; -1; 2\"\n        keyTimes=\"0; 0.25; 1\"\n        dur=\"2s\"\n        repeatCount=\"indefinite\"\n      ></animate>\n    </stop>\n    <stop\n      offset=\"2.59996\"\n      stop-color=\"#f3f3f3\"\n      stop-opacity=\"1\"\n    >\n      <animate\n        attributeName=\"offset\"\n        values=\"0; 0; 3\"\n        keyTimes=\"0; 0.25; 1\"\n        dur=\"2s\"\n        repeatCount=\"indefinite\"\n      ></animate>\n    </stop>\n  </linearGradient>\n`\n\nconst rect = ({ x, y, width, height }) => `\n  <rect rx=\"3\" ry=\"3\" x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${height}\" />\n`\nconst use = ({ id, x, y }) => `\n  <use href=\"#${id}\" x=\"${x}\" y=\"${y}\" />\n`\nconst path = ({ path, id }) => `\n  <path id=\"${id}\" d=\"${path}\" />\n`\n\nconst renderRefs = (groups) =>\n  groups.reduce(\n    (acc, group) => acc + group.positions.map(\n      (position) => use({ ...group, ...position })\n    ).join('')\n  , '')\n\nexport const template = trim(({\n  width,\n  height,\n  singles,\n  groups\n}) => `\n<svg width=\"${width}\" height=\"${height}\" viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"none\">\n  <rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" clip-path=\"url(#clip)\" style='fill: url(\"#fill\");'></rect>\n  <defs>\n    ${groups.map(path).join('')}\n    <clipPath id=\"clip\">\n      ${renderRefs(groups)}\n      ${singles.map(rect).join('')}\n    </clipPath>\n    ${animation}\n  <defs>\n</svg>\n`)\n","// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nimport { urlAlphabet } from './url-alphabet/index.js'\n\nif (process.env.NODE_ENV !== 'production') {\n  // All bundlers will remove this block in the production bundle.\n  if (\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative' &&\n    typeof crypto === 'undefined'\n  ) {\n    throw new Error(\n      'React Native does not have a built-in secure random generator. ' +\n        'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' +\n        'For secure IDs, import `react-native-get-random-values` ' +\n        'before Nano ID. If you use Expo, install `expo-random` ' +\n        'and use `nanoid/async`.'\n    )\n  }\n  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {\n    throw new Error(\n      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +\n        ' before importing Nano ID to fix IE 11 support'\n    )\n  }\n  if (typeof crypto === 'undefined') {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n        'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\n\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\n\nlet customRandom = (alphabet, size, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  // `Math.clz32` is not used, because it is not available in browsers.\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n\n  // `-~f => Math.ceil(f)` if f is a float\n  // `-~i => i + 1` if i is an integer\n  let step = -~((1.6 * mask * size) / alphabet.length)\n\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\n      let j = step\n      while (j--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[j] & mask] || ''\n        // `id.length + 1 === size` is a more compact option.\n        if (id.length === +size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\n  while (size--) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\n\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","import toPath from 'element-to-path';\nimport { template } from './templates';\nimport { nanoid } from 'nanoid';\n\nconst SELECTORS = {\n  container: '[data-draw=\\'container\\']',\n  group: '[data-draw=\\'group\\']',\n  text: '[data-draw=\\'text\\']',\n  rect: '[data-draw=\\'rect\\']',\n  border: '[data-draw=\\'border\\']',\n}\n\nconst defaultGroupIdentifier = (node) => node.dataset['draw-id'];\n\nconst defaultConfig = {\n  container: SELECTORS.container,\n  group: SELECTORS.group,\n  text: SELECTORS.text,\n  rect: SELECTORS.rect,\n  border: SELECTORS.border,\n  identifyGroup: defaultGroupIdentifier\n}\n\nconst isHidden = node => !(node.offsetWidth || node.offsetHeight || node.getClientRects().length);\n\nconst getPosition = (node, containerRect) => {\n  const nodeRect = node.getBoundingClientRect();\n  return {\n    left: nodeRect.left - containerRect.left,\n    top: nodeRect.top - containerRect.top,\n    width: nodeRect.width,\n    height: nodeRect.height,\n  }\n}\n\nconst getElementHeight = (style) => {\n  const boxSizing = style.getPropertyValue(\"box-sizing\");\n  const height = parseInt(style.getPropertyValue(\"height\"));\n  if (boxSizing !== 'border-box') return height;\n  const paddingTop = parseInt(style.getPropertyValue(\"padding-top\"));\n  const paddingBottom = parseInt(style.getPropertyValue(\"padding-bottom\"));\n  const borderTop = parseInt(style.getPropertyValue(\"border-top-width\"));\n  const borderBottom = parseInt(style.getPropertyValue(\"border-bottom-width\"));\n  return height - paddingTop - paddingBottom - borderTop - borderBottom;\n}\n\nconst getNodeStyles = (node) => window.getComputedStyle(node, null);\n\nconst countLines = (node) => {\n  const style = getNodeStyles(node);\n  const _fontSize = parseInt(style.getPropertyValue(\"font-size\"));\n  const _lineHeight = parseInt(style.getPropertyValue(\"line-height\"));\n  const lineHeight = isNaN(_lineHeight) ? _fontSize : _lineHeight\n  const height = getElementHeight(style);\n  return {\n    lines: (height < lineHeight * 2) ? 1 : Math.ceil(height / lineHeight),\n    lineHeight: lineHeight\n  };\n}\n\nconst getRange = (node) => {\n  const range = document.createRange();\n  range.selectNode(node);\n  return range.getClientRects();\n}\n\nconst elements = {\n  text(node, containerRect) {\n    if (isHidden(node)) return;\n    const position = getPosition(node, containerRect);\n    const { lines, lineHeight } = countLines(node);\n\n    if (lines === 1) {\n      const rangeOffset = getRange(node);\n      position.left = rangeOffset[1].x - 20;\n      position.width = rangeOffset[1].width;\n    }\n\n    const { left, top, width, height } = position;\n\n    return [...Array(lines).keys()].map((index) => ({\n      x: left,\n      y: !index ? top : top + (index * lineHeight) + (index * 5),\n      height: height < lineHeight ? height : lineHeight,\n      width,\n    }))\n  },\n\n  rect(node, containerRect) {\n    const position = getPosition(node, containerRect);\n    const style = getNodeStyles(node);\n    const paddingLeft = parseInt(style.getPropertyValue(\"padding-left\"));\n    const paddingRight = parseInt(style.getPropertyValue(\"padding-right\"));\n    const { left, top, width, height } = position;\n\n    return [{\n      x: left + paddingLeft,\n      y: top,\n      width: width + paddingRight,\n      height\n    }]\n  },\n}\n\nconst walkThroughNodes = (type, nodes, parentRect) =>\n  Array.from(nodes)\n    .map((node) => elements[type](node, parentRect))\n    .filter(i => !!i)\n    .reduce((acc, item) => [...acc, ...item] ,[]);\n\nconst getGroup = (groupNodes, config) => {\n  const fistNode = groupNodes[0];\n  const groupRect = fistNode.getBoundingClientRect();\n  const textNodes = fistNode.querySelectorAll(config.text);\n  const rectNodes = fistNode.querySelectorAll(config.rect);\n\n  const groupElements = [\n    ...walkThroughNodes('text', textNodes, groupRect),\n    ...walkThroughNodes('rect', rectNodes, groupRect)\n  ]\n\n  const path = groupElements\n    .map((attributes) => toPath({ type: 'element', name: 'rect', attributes }))\n    .join(' ')\n\n  const positions = groupNodes.map((node) => {\n    const { x, y } = node.getBoundingClientRect();\n    return { x, y };\n  });\n\n  return {\n    positions,\n    path,\n    id: nanoid()\n  }\n}\n\nconst getPaths = (type, selector, container, groups) => {\n  const parentRect = container.getBoundingClientRect();\n  const groupsArray = Array.from(groups);\n  const nodes = Array\n    .from(container.querySelectorAll(selector))\n    .filter((node) =>\n      !groups.find(group => Array.from(group.querySelectorAll(selector)).includes(node))\n    );\n  \n  return walkThroughNodes(type, nodes, parentRect);\n}\n\nconst getMainDrawing = (container, config) => {\n  const { width, height } = container.getBoundingClientRect();\n  const groupNodes = Array.from(container.querySelectorAll(config.group));\n  const groupsHash = groupNodes\n    .reduce((acc, node) => {\n      const id = config.identifyGroup(node);\n      if (!acc[id]) return { ...acc, [id]: [node] };\n      return { ...acc, [id]: [...acc[id], node ] };\n    }, {});\n  \n  const groups = Object.keys(groupsHash).map(id => getGroup(groupsHash[id], config));\n  const singles = [\n    ...getPaths('text', config.text, container, groupNodes),\n    ...getPaths('rect', config.rect, container, groupNodes)\n  ]\n\n  return template({ width, height, singles, groups })\n}\n\nexport default (_config) => {\n  const config = { ...defaultConfig, ..._config };\n  if (!document) return console.error('Function available only in browser environment!');\n\n  const container = document.querySelectorAll(config.container);\n  if (!container) return console.error('FNo containers was found on the page');\n\n  const res = Array\n    .from(container)\n    .map(c => getMainDrawing(c, config));\n\n  return res;\n}\n"],"names":["module","calcValue","val","base","test","replace","poly","attrs","points","arr","size","results","length","push","splice","chunkArray","trim","split","reduce","point","includes","map","x","y","i","node","nodeName","nodeAttrs","name","attributes","d","w","width","h","height","rx","ry","hasCurves","rect","cx","cy","r","ellipse","x1","y1","x2","y2","line","Array","isArray","join","toPathString","factory","path","id","template","string","singles","groups","acc","group","positions","position","use","renderRefs","props","process","env","NODE_ENV","navigator","product","crypto","Error","msCrypto","nanoid","bytes","getRandomValues","Uint8Array","byte","toString","toUpperCase","defaultConfig","container","text","border","identifyGroup","dataset","getPosition","containerRect","nodeRect","getBoundingClientRect","left","top","getNodeStyles","window","getComputedStyle","elements","offsetWidth","offsetHeight","getClientRects","isHidden","lines","lineHeight","style","_fontSize","parseInt","getPropertyValue","_lineHeight","isNaN","boxSizing","getElementHeight","Math","ceil","countLines","rangeOffset","range","document","createRange","selectNode","getRange","keys","index","paddingLeft","paddingRight","walkThroughNodes","type","nodes","parentRect","from","filter","item","getPaths","selector","querySelectorAll","find","_config","config","console","error","c","groupNodes","groupsHash","[object Object]","Object","fistNode","groupRect","textNodes","rectNodes","toPath","getGroup","getMainDrawing"],"mappings":"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"}