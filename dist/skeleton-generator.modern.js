function e(){return(e=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var t,n=(function(e,t){e.exports=function(){const e=(e,t)=>/%$/.test(e)?100*e.replace("%","")/t:+e,t=e=>{const{points:t}=e;return((e,t=2)=>{let n=[];for(;e.length;)n.push(e.splice(0,t));return n})(t.trim().split(" ").reduce((e,t)=>[...e,...t.includes(",")?t.split(","):[t]],[]),2).map(([e,t],n)=>`${0===n?"M":"L"}${e} ${t}`)};return(n,{nodeName:r="name",nodeAttrs:o="attributes"}={})=>{const i=n[r],a=n[o];let s;return"rect"===i&&(s=(t=>{const n=+t.width,r=+t.height,o=t.x?+t.x:0,i=t.y?+t.y:0;let a=t.rx||"auto",s=t.ry||"auto";"auto"===a&&"auto"===s?a=s=0:"auto"!==a&&"auto"===s?a=s=e(a,n):"auto"!==s&&"auto"===a?s=a=e(s,r):(a=e(a,n),s=e(s,r)),a>n/2&&(a=n/2),s>r/2&&(s=r/2);const p=a>0&&s>0;return[`M${o+a} ${i}`,"H"+(o+n-a),...p?[`A${a} ${s} 0 0 1 ${o+n} ${i+s}`]:[],"V"+(i+r-s),...p?[`A${a} ${s} 0 0 1 ${o+n-a} ${i+r}`]:[],"H"+(o+a),...p?[`A${a} ${s} 0 0 1 ${o} ${i+r-s}`]:[],"V"+(i+s),...p?[`A${a} ${s} 0 0 1 ${o+a} ${i}`]:[],"z"]})(a)),"circle"!==i&&"ellipse"!==i||(s=(e=>{const t=+e.cx,n=+e.cy,r=e.rx?+e.rx:+e.r,o=e.ry?+e.ry:+e.r;return[`M${t+r} ${n}`,`A${r} ${o} 0 0 1 ${t} ${n+o}`,`A${r} ${o} 0 0 1 ${t-r} ${n}`,`A${r} ${o} 0 0 1 ${t+r} ${n}`,"z"]})(a)),"line"===i&&(s=(({x1:e,y1:t,x2:n,y2:r})=>[`M${+e} ${+t}`,`L${+n} ${+r}`])(a)),"polyline"===i&&(s=t(a)),"polygon"===i&&(s=[...t(a),"Z"]),"path"===i?a.d:(e=>Array.isArray(e)?e.join(" "):"")(s)}}()}(t={path:void 0,exports:{},require:function(e,t){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}()}}),t.exports);const r=({x:e,y:t,width:n,height:r})=>`\n  <rect rx="3" ry="3" x="${e}" y="${t}" width="${n}" height="${r}" />\n`,o=({path:e,id:t})=>`\n  <path id="${t}" d="${e}" />\n`,i=(a=({width:t,height:n,singles:i,groups:a})=>`\n<svg width="${t}" height="${n}" viewBox="0 0 ${t} ${n}" preserveAspectRatio="none">\n  <rect x="0" y="0" width="100%" height="100%" clip-path="url(#clip)" style='fill: url("#fill");'></rect>\n  <defs>\n    ${a.map(o).join("")}\n    <clipPath id="clip">\n      ${(t=>t.reduce((t,n)=>t+n.positions.map(t=>(({id:e,x:t,y:n})=>`\n  <use href="#${e}" x="${t}" y="${n}" />\n`)(e({},n,t))).join(""),""))(a)}\n      ${i.map(r).join("")}\n    </clipPath>\n    \n  <linearGradient id="fill">\n    <stop\n      offset="0.599964"\n      stop-color="#f3f3f3"\n      stop-opacity="1"\n    >\n      <animate\n        attributeName="offset"\n        values="-2; -2; 1"\n        keyTimes="0; 0.25; 1"\n        dur="2s"\n        repeatCount="indefinite"\n      ></animate>\n    </stop>\n    <stop\n      offset="1.59996"\n      stop-color="#ecebeb"\n      stop-opacity="1"\n    >\n      <animate\n        attributeName="offset"\n        values="-1; -1; 2"\n        keyTimes="0; 0.25; 1"\n        dur="2s"\n        repeatCount="indefinite"\n      ></animate>\n    </stop>\n    <stop\n      offset="2.59996"\n      stop-color="#f3f3f3"\n      stop-opacity="1"\n    >\n      <animate\n        attributeName="offset"\n        values="0; 0; 3"\n        keyTimes="0; 0.25; 1"\n        dur="2s"\n        repeatCount="indefinite"\n      ></animate>\n    </stop>\n  </linearGradient>\n\n  <defs>\n</svg>\n`,e=>a(e).replace(/(\r\n|\n|\r)/gm,""));var a;if("production"!==process.env.NODE_ENV){if("undefined"!=typeof navigator&&"ReactNative"===navigator.product&&"undefined"==typeof crypto)throw new Error("React Native does not have a built-in secure random generator. If you don’t need unpredictable IDs use `nanoid/non-secure`. For secure IDs, import `react-native-get-random-values` before Nano ID. If you use Expo, install `expo-random` and use `nanoid/async`.");if("undefined"!=typeof msCrypto&&"undefined"==typeof crypto)throw new Error("Import file with `if (!window.crypto) window.crypto = window.msCrypto` before importing Nano ID to fix IE 11 support");if("undefined"==typeof crypto)throw new Error("Your browser does not have secure random generator. If you don’t need unpredictable IDs, you can use nanoid/non-secure.")}let s=(e=21)=>{let t="",n=crypto.getRandomValues(new Uint8Array(e));for(;e--;){let r=63&n[e];t+=r<36?r.toString(36):r<62?(r-26).toString(36).toUpperCase():r<63?"_":"-"}return t};const p={container:"[data-draw='container']",group:"[data-draw='group']",text:"[data-draw='text']",rect:"[data-draw='rect']",border:"[data-draw='border']",identifyGroup:e=>e.dataset["draw-id"]},u=(e,t)=>{const n=e.getBoundingClientRect();return{left:n.left-t.left,top:n.top-t.top,width:n.width,height:n.height}},l=e=>window.getComputedStyle(e,null),d={text(e,t){if((e=>!(e.offsetWidth||e.offsetHeight||e.getClientRects().length))(e))return;const n=u(e,t),{lines:r,lineHeight:o}=(e=>{const t=l(e),n=parseInt(t.getPropertyValue("font-size")),r=parseInt(t.getPropertyValue("line-height")),o=isNaN(r)?n:r,i=(e=>{const t=e.getPropertyValue("box-sizing"),n=parseInt(e.getPropertyValue("height"));return"border-box"!==t?n:n-parseInt(e.getPropertyValue("padding-top"))-parseInt(e.getPropertyValue("padding-bottom"))-parseInt(e.getPropertyValue("border-top-width"))-parseInt(e.getPropertyValue("border-bottom-width"))})(t);return{lines:i<2*o?1:Math.ceil(i/o),lineHeight:o}})(e);if(1===r){const t=(e=>{const t=document.createRange();return t.selectNode(e),t.getClientRects()})(e);n.left=t[1].x-20,n.width=t[1].width}const{left:i,top:a,width:s,height:p}=n;return[...Array(r).keys()].map(e=>({x:i,y:e?a+e*o+5*e:a,height:p<o?p:o,width:s}))},rect(e,t){const n=u(e,t),r=l(e),o=parseInt(r.getPropertyValue("padding-left")),i=parseInt(r.getPropertyValue("padding-right")),{left:a,top:s,width:p,height:d}=n;return[{x:a+o,y:s,width:p+i,height:d}]}},c=(e,t,n)=>Array.from(t).map(t=>d[e](t,n)).filter(e=>!!e).reduce((e,t)=>[...e,...t],[]),f=(e,t,n,r)=>{const o=n.getBoundingClientRect(),i=Array.from(n.querySelectorAll(t)).filter(e=>!r.find(n=>Array.from(n.querySelectorAll(t)).includes(e)));return c(e,i,o)};export default t=>{const r=e({},p,t);if(!document)return console.error("Function available only in browser environment!");const o=document.querySelectorAll(r.container);return o?Array.from(o).map(t=>((t,r)=>{const{width:o,height:a}=t.getBoundingClientRect(),p=Array.from(t.querySelectorAll(r.group)),u=p.reduce((t,n)=>{const o=r.identifyGroup(n);return e({},t,t[o]?{[o]:[...t[o],n]}:{[o]:[n]})},{}),l=Object.keys(u).map(e=>((e,t)=>{const r=e[0],o=r.getBoundingClientRect(),i=r.querySelectorAll(t.text),a=r.querySelectorAll(t.rect),p=[...c("text",i,o),...c("rect",a,o)].map(e=>n({type:"element",name:"rect",attributes:e})).join(" ");return{positions:e.map(e=>{const{x:t,y:n}=e.getBoundingClientRect();return{x:t,y:n}}),path:p,id:s()}})(u[e],r)),d=[...f("text",r.text,t,p),...f("rect",r.rect,t,p)];return i({width:o,height:a,singles:d,groups:l})})(t,r)):console.error("FNo containers was found on the page")};
//# sourceMappingURL=skeleton-generator.modern.js.map
