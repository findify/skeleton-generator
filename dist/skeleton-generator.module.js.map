{"version":3,"file":"skeleton-generator.module.js","sources":["../templates.js","../node_modules/element-to-path/dist/element-to-path.umd.js","../node_modules/nanoid/index.browser.js","../index.js"],"sourcesContent":["export const trim = string => props => string(props)\n  .replace(/(\\r\\n|\\n|\\r)/gm, \"\")\n\nexport const animation = `\n  <linearGradient id=\"fill\">\n    <stop\n      offset=\"0.599964\"\n      stop-color=\"#f3f3f3\"\n      stop-opacity=\"1\"\n    >\n      <animate\n        attributeName=\"offset\"\n        values=\"-2; -2; 1\"\n        keyTimes=\"0; 0.25; 1\"\n        dur=\"2s\"\n        repeatCount=\"indefinite\"\n      ></animate>\n    </stop>\n    <stop\n      offset=\"1.59996\"\n      stop-color=\"#ecebeb\"\n      stop-opacity=\"1\"\n    >\n      <animate\n        attributeName=\"offset\"\n        values=\"-1; -1; 2\"\n        keyTimes=\"0; 0.25; 1\"\n        dur=\"2s\"\n        repeatCount=\"indefinite\"\n      ></animate>\n    </stop>\n    <stop\n      offset=\"2.59996\"\n      stop-color=\"#f3f3f3\"\n      stop-opacity=\"1\"\n    >\n      <animate\n        attributeName=\"offset\"\n        values=\"0; 0; 3\"\n        keyTimes=\"0; 0.25; 1\"\n        dur=\"2s\"\n        repeatCount=\"indefinite\"\n      ></animate>\n    </stop>\n  </linearGradient>\n`\n\nconst rect = ({ x, y, width, height }) => `\n  <rect rx=\"3\" ry=\"3\" x=\"${x}\" y=\"${y}\" width=\"${width}\" height=\"${height}\" />\n`\nconst use = ({ id, x, y }) => `\n  <use href=\"#${id}\" x=\"${x}\" y=\"${y}\" />\n`\nconst path = ({ path, id }) => `\n  <path id=\"${id}\" d=\"${path}\" />\n`\n\nconst renderRefs = (groups) =>\n  groups.reduce(\n    (acc, group) => acc + group.positions.map(\n      (position) => use({ ...group, ...position })\n    ).join('')\n  , '')\n\nexport const template = trim(({\n  width,\n  height,\n  singles,\n  groups\n}) => `\n<svg width=\"${width}\" height=\"${height}\" viewBox=\"0 0 ${width} ${height}\" preserveAspectRatio=\"none\">\n  <rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" clip-path=\"url(#clip)\" style='fill: url(\"#fill\");'></rect>\n  <defs>\n    ${groups.map(path).join('')}\n    <clipPath id=\"clip\">\n      ${renderRefs(groups)}\n      ${singles.map(rect).join('')}\n    </clipPath>\n    ${animation}\n  <defs>\n</svg>\n`)\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.elementToPath = factory());\n}(this, (function () { 'use strict';\n\n  const chunkArray = (arr, size = 2) => {\n    let results = [];\n    while (arr.length) {\n      results.push(arr.splice(0, size));\n    }\n    return results\n  };\n\n  const calcValue = (val, base) => {\n    return /%$/.test(val) ? (val.replace('%', '') * 100) / base : +val\n  };\n\n  const rect = attrs => {\n    const w = +attrs.width;\n    const h = +attrs.height;\n    const x = attrs.x ? +attrs.x : 0;\n    const y = attrs.y ? +attrs.y : 0;\n    let rx = attrs.rx || 'auto';\n    let ry = attrs.ry || 'auto';\n    if (rx === 'auto' && ry === 'auto') {\n      rx = ry = 0;\n    } else if (rx !== 'auto' && ry === 'auto') {\n      rx = ry = calcValue(rx, w);\n    } else if (ry !== 'auto' && rx === 'auto') {\n      ry = rx = calcValue(ry, h);\n    } else {\n      rx = calcValue(rx, w);\n      ry = calcValue(ry, h);\n    }\n    if (rx > w / 2) {\n      rx = w / 2;\n    }\n    if (ry > h / 2) {\n      ry = h / 2;\n    }\n    const hasCurves = rx > 0 && ry > 0;\n    return [\n      `M${x + rx} ${y}`,\n      `H${x + w - rx}`,\n      ...(hasCurves ? [`A${rx} ${ry} 0 0 1 ${x + w} ${y + ry}`] : []),\n      `V${y + h - ry}`,\n      ...(hasCurves ? [`A${rx} ${ry} 0 0 1 ${x + w - rx} ${y + h}`] : []),\n      `H${x + rx}`,\n      ...(hasCurves ? [`A${rx} ${ry} 0 0 1 ${x} ${y + h - ry}`] : []),\n      `V${y + ry}`,\n      ...(hasCurves ? [`A${rx} ${ry} 0 0 1 ${x + rx} ${y}`] : []),\n      'z',\n    ]\n  };\n\n  const ellipse = attrs => {\n    const cx = +attrs.cx;\n    const cy = +attrs.cy;\n    const rx = attrs.rx ? +attrs.rx : +attrs.r;\n    const ry = attrs.ry ? +attrs.ry : +attrs.r;\n    return [\n      `M${cx + rx} ${cy}`,\n      `A${rx} ${ry} 0 0 1 ${cx} ${cy + ry}`,\n      `A${rx} ${ry} 0 0 1 ${cx - rx} ${cy}`,\n      `A${rx} ${ry} 0 0 1 ${cx + rx} ${cy}`,\n      'z',\n    ]\n  };\n\n  const line = ({ x1, y1, x2, y2 }) => {\n    return [`M${+x1} ${+y1}`, `L${+x2} ${+y2}`]\n  };\n\n  const poly = attrs => {\n    const { points } = attrs;\n    const pointsArray = points\n      .trim()\n      .split(' ')\n      .reduce((arr, point) => {\n        return [...arr, ...(point.includes(',') ? point.split(',') : [point])]\n      }, []);\n\n    const pairs = chunkArray(pointsArray, 2);\n    return pairs.map(([x, y], i) => {\n      return `${i === 0 ? 'M' : 'L'}${x} ${y}`\n    })\n  };\n\n  const toPathString = d => {\n    return Array.isArray(d) ? d.join(' ') : ''\n  };\n\n  const elementToPath = (\n    node,\n    { nodeName = 'name', nodeAttrs = 'attributes' } = {}\n  ) => {\n    const name = node[nodeName];\n    const attributes = node[nodeAttrs];\n    let d;\n    if (name === 'rect') {\n      d = rect(attributes);\n    }\n\n    if (name === 'circle' || name === 'ellipse') {\n      d = ellipse(attributes);\n    }\n\n    if (name === 'line') {\n      d = line(attributes);\n    }\n\n    if (name === 'polyline') {\n      d = poly(attributes);\n    }\n\n    if (name === 'polygon') {\n      d = [...poly(attributes), 'Z'];\n    }\n\n    if (name === 'path') {\n      return attributes.d\n    }\n\n    return toPathString(d)\n  };\n\n  return elementToPath;\n\n})));\n","// This file replaces `index.js` in bundlers like webpack or Rollup,\n// according to `browser` config in `package.json`.\n\nimport { urlAlphabet } from './url-alphabet/index.js'\n\nif (process.env.NODE_ENV !== 'production') {\n  // All bundlers will remove this block in the production bundle.\n  if (\n    typeof navigator !== 'undefined' &&\n    navigator.product === 'ReactNative' &&\n    typeof crypto === 'undefined'\n  ) {\n    throw new Error(\n      'React Native does not have a built-in secure random generator. ' +\n        'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' +\n        'For secure IDs, import `react-native-get-random-values` ' +\n        'before Nano ID. If you use Expo, install `expo-random` ' +\n        'and use `nanoid/async`.'\n    )\n  }\n  if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {\n    throw new Error(\n      'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +\n        ' before importing Nano ID to fix IE 11 support'\n    )\n  }\n  if (typeof crypto === 'undefined') {\n    throw new Error(\n      'Your browser does not have secure random generator. ' +\n        'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'\n    )\n  }\n}\n\nlet random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\n\nlet customRandom = (alphabet, size, getRandom) => {\n  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes\n  // values closer to the alphabet size. The bitmask calculates the closest\n  // `2^31 - 1` number, which exceeds the alphabet size.\n  // For example, the bitmask for the alphabet size 30 is 31 (00011111).\n  // `Math.clz32` is not used, because it is not available in browsers.\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  // Though, the bitmask solution is not perfect since the bytes exceeding\n  // the alphabet size are refused. Therefore, to reliably generate the ID,\n  // the random bytes redundancy has to be satisfied.\n\n  // Note: every hardware random generator call is performance expensive,\n  // because the system call for entropy collection takes a lot of time.\n  // So, to avoid additional system calls, extra bytes are requested in advance.\n\n  // Next, a step determines how many random bytes to generate.\n  // The number of random bytes gets decided upon the ID size, mask,\n  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance\n  // according to benchmarks).\n\n  // `-~f => Math.ceil(f)` if f is a float\n  // `-~i => i + 1` if i is an integer\n  let step = -~((1.6 * mask * size) / alphabet.length)\n\n  return () => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      // A compact alternative for `for (var i = 0; i < step; i++)`.\n      let j = step\n      while (j--) {\n        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.\n        id += alphabet[bytes[j] & mask] || ''\n        // `id.length + 1 === size` is a more compact option.\n        if (id.length === +size) return id\n      }\n    }\n  }\n}\n\nlet customAlphabet = (alphabet, size) => customRandom(alphabet, size, random)\n\nlet nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array(size))\n\n  // A compact alternative for `for (var i = 0; i < step; i++)`.\n  while (size--) {\n    // It is incorrect to use bytes exceeding the alphabet size.\n    // The following mask reduces the random byte in the 0-255 value\n    // range to the 0-63 value range. Therefore, adding hacks, such\n    // as empty string fallback or magic numbers, is unneccessary because\n    // the bitmask trims bytes down to the alphabet size.\n    let byte = bytes[size] & 63\n    if (byte < 36) {\n      // `0-9a-z`\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      // `A-Z`\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte < 63) {\n      id += '_'\n    } else {\n      id += '-'\n    }\n  }\n  return id\n}\n\nexport { nanoid, customAlphabet, customRandom, urlAlphabet, random }\n","import toPath from 'element-to-path';\nimport { template } from './templates';\nimport { nanoid } from 'nanoid';\n\nconst SELECTORS = {\n  container: '[data-draw=\\'container\\']',\n  group: '[data-draw=\\'group\\']',\n  text: '[data-draw=\\'text\\']',\n  rect: '[data-draw=\\'rect\\']',\n  border: '[data-draw=\\'border\\']',\n}\n\nconst defaultGroupIdentifier = (node) => node.dataset['draw-id'];\n\nconst defaultConfig = {\n  container: SELECTORS.container,\n  group: SELECTORS.group,\n  text: SELECTORS.text,\n  rect: SELECTORS.rect,\n  border: SELECTORS.border,\n  identifyGroup: defaultGroupIdentifier\n}\n\nconst isHidden = node => !(node.offsetWidth || node.offsetHeight || node.getClientRects().length);\n\nconst getPosition = (node, containerRect) => {\n  const nodeRect = node.getBoundingClientRect();\n  return {\n    left: nodeRect.left - containerRect.left,\n    top: nodeRect.top - containerRect.top,\n    width: nodeRect.width,\n    height: nodeRect.height,\n  }\n}\n\nconst getElementHeight = (style) => {\n  const boxSizing = style.getPropertyValue(\"box-sizing\");\n  const height = parseInt(style.getPropertyValue(\"height\"));\n  if (boxSizing !== 'border-box') return height;\n  const paddingTop = parseInt(style.getPropertyValue(\"padding-top\"));\n  const paddingBottom = parseInt(style.getPropertyValue(\"padding-bottom\"));\n  const borderTop = parseInt(style.getPropertyValue(\"border-top-width\"));\n  const borderBottom = parseInt(style.getPropertyValue(\"border-bottom-width\"));\n  return height - paddingTop - paddingBottom - borderTop - borderBottom;\n}\n\nconst getNodeStyles = (node) => window.getComputedStyle(node, null);\n\nconst countLines = (node) => {\n  const style = getNodeStyles(node);\n  const _fontSize = parseInt(style.getPropertyValue(\"font-size\"));\n  const _lineHeight = parseInt(style.getPropertyValue(\"line-height\"));\n  const lineHeight = isNaN(_lineHeight) ? _fontSize : _lineHeight\n  const height = getElementHeight(style);\n  return {\n    lines: (height < lineHeight * 2) ? 1 : Math.ceil(height / lineHeight),\n    lineHeight: lineHeight\n  };\n}\n\nconst getRange = (node) => {\n  const range = document.createRange();\n  range.selectNode(node);\n  return range.getClientRects();\n}\n\nconst elements = {\n  text(node, containerRect) {\n    if (isHidden(node)) return;\n    const position = getPosition(node, containerRect);\n    const { lines, lineHeight } = countLines(node);\n\n    if (lines === 1) {\n      const rangeOffset = getRange(node);\n      position.left = rangeOffset[1].x - 20;\n      position.width = rangeOffset[1].width;\n    }\n\n    const { left, top, width, height } = position;\n\n    return [...Array(lines).keys()].map((index) => ({\n      x: left,\n      y: !index ? top : top + (index * lineHeight) + (index * 5),\n      height: height < lineHeight ? height : lineHeight,\n      width,\n    }))\n  },\n\n  rect(node, containerRect) {\n    const position = getPosition(node, containerRect);\n    const style = getNodeStyles(node);\n    const paddingLeft = parseInt(style.getPropertyValue(\"padding-left\"));\n    const paddingRight = parseInt(style.getPropertyValue(\"padding-right\"));\n    const { left, top, width, height } = position;\n\n    return [{\n      x: left + paddingLeft,\n      y: top,\n      width: width + paddingRight,\n      height\n    }]\n  },\n}\n\nconst walkThroughNodes = (type, nodes, parentRect) =>\n  Array.from(nodes)\n    .map((node) => elements[type](node, parentRect))\n    .filter(i => !!i)\n    .reduce((acc, item) => [...acc, ...item] ,[]);\n\nconst getGroup = (groupNodes, config) => {\n  const fistNode = groupNodes[0];\n  const groupRect = fistNode.getBoundingClientRect();\n  const textNodes = fistNode.querySelectorAll(config.text);\n  const rectNodes = fistNode.querySelectorAll(config.rect);\n\n  const groupElements = [\n    ...walkThroughNodes('text', textNodes, groupRect),\n    ...walkThroughNodes('rect', rectNodes, groupRect)\n  ]\n\n  const path = groupElements\n    .map((attributes) => toPath({ type: 'element', name: 'rect', attributes }))\n    .join(' ')\n\n  const positions = groupNodes.map((node) => {\n    const { x, y } = node.getBoundingClientRect();\n    return { x, y };\n  });\n\n  return {\n    positions,\n    path,\n    id: nanoid()\n  }\n}\n\nconst getPaths = (type, selector, container, groups) => {\n  const parentRect = container.getBoundingClientRect();\n  const groupsArray = Array.from(groups);\n  const nodes = Array\n    .from(container.querySelectorAll(selector))\n    .filter((node) =>\n      !groups.find(group => Array.from(group.querySelectorAll(selector)).includes(node))\n    );\n  \n  return walkThroughNodes(type, nodes, parentRect);\n}\n\nconst getMainDrawing = (container, config) => {\n  const { width, height } = container.getBoundingClientRect();\n  const groupNodes = Array.from(container.querySelectorAll(config.group));\n  const groupsHash = groupNodes\n    .reduce((acc, node) => {\n      const id = config.identifyGroup(node);\n      if (!acc[id]) return { ...acc, [id]: [node] };\n      return { ...acc, [id]: [...acc[id], node ] };\n    }, {});\n  \n  const groups = Object.keys(groupsHash).map(id => getGroup(groupsHash[id], config));\n  const singles = [\n    ...getPaths('text', config.text, container, groupNodes),\n    ...getPaths('rect', config.rect, container, groupNodes)\n  ]\n\n  return template({ width, height, singles, groups })\n}\n\nexport default (_config) => {\n  const config = { ...defaultConfig, ..._config };\n  if (!document) return console.error('Function available only in browser environment!');\n\n  const container = document.querySelectorAll(config.container);\n  if (!container) return console.error('FNo containers was found on the page');\n\n  const res = Array\n    .from(container)\n    .map(c => getMainDrawing(c, config));\n\n  return res;\n}\n"],"names":["string","module","calcValue","val","base","test","replace","poly","attrs","points","arr","size","results","length","push","splice","chunkArray","trim","split","reduce","point","includes","map","x","y","i","node","nodeName","nodeAttrs","name","attributes","d","w","width","h","height","rx","ry","hasCurves","rect","cx","cy","r","ellipse","x1","y1","x2","y2","line","Array","isArray","join","toPathString","factory","path","id","template","singles","groups","acc","group","positions","position","renderRefs","props","process","env","NODE_ENV","navigator","product","crypto","Error","msCrypto","nanoid","bytes","getRandomValues","Uint8Array","byte","toString","toUpperCase","defaultConfig","container","text","border","identifyGroup","dataset","getPosition","containerRect","nodeRect","getBoundingClientRect","left","top","getNodeStyles","window","getComputedStyle","elements","offsetWidth","offsetHeight","getClientRects","isHidden","style","_fontSize","parseInt","getPropertyValue","_lineHeight","lineHeight","isNaN","boxSizing","getElementHeight","lines","Math","ceil","countLines","rangeOffset","range","document","createRange","selectNode","getRange","keys","index","paddingLeft","paddingRight","walkThroughNodes","type","nodes","parentRect","from","filter","item","getPaths","selector","querySelectorAll","find","_config","config","console","error","c","groupNodes","groupsHash","Object","fistNode","groupRect","textNodes","rectNodes","toPath","getGroup","getMainDrawing"],"mappings":"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"}